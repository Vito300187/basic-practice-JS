# basic-practice-JS

*This repository contains the best tests that I was lucky enough to deal with during the training on the Hexlet platform!*

![Hexlet logo](https://open-education.net/wp-content/uploads/2014/07/416970e1e2d4bb03297ec21b80507d2a-720x340.jpg)

## bubbleSort.js

Реализуйте функцию ```bubbleSort()```

Пузырьковая сортировка (bubble sort)

Алгоритм состоит из повторяющихся проходов по сортируемому массиву. За каждый проход элементы последовательно сравниваются попарно и, если порядок в паре неверный, выполняется обмен элементов. Проходы по массиву повторяются N-1 раз или до тех пор, пока на очередном проходе не окажется, что обмены больше не нужны, что означает — массив отсортирован. При каждом проходе алгоритма по внутреннему циклу, очередной наибольший элемент массива ставится на своё место в конце массива рядом с предыдущим «наибольшим элементом», а наименьший элемент перемещается на одну позицию к началу массива («всплывает» до нужной позиции, как пузырёк в воде. Отсюда и название алгоритма).

**Вывод:**

```JavaScript
console.log(bubbleSort([14, 20, -10, -63, 0, 100, 33, -33]));
// [-63, -33, -10, 0, 14, 20, 33, 100]
```

## capitalizeWords.js

Дана строка текста. Нужно сделать заглавной **первую** букву каждого слова в тексте. Для простоты считаем что мы работаем с текстом, который не содержит знаков препинания.

Реализуйте функцию ```capitalizeWords()```

**Вывод:**

```JavaScript
const text = 'hello world';
capitalizeWords(text); // 'Hello World'
```

Данное задание решить через преобразование строк в массив.

## encrypt.js

Разработайте программу, которая бы шифровала сообщения по следующему алгоритму. Она бы брала текст и переставляла в нем каждые два подряд идущих символа.

**Вывод:**

```JavaScript
encrypt('JavaScript');   // 'aJavcSirtp'
encrypt('Python'); // 'yPhtno'
 
// Если число символов нечётное,
// то последний символ остаётся на своём месте
encrypt('PHP'); // 'HPP'
```

Реализуйте функцию ```encrypt()```, которая принимает на вход исходное сообщение и возвращает зашифрованное.

## fibonacci-number.js

*Чи́сла Фибона́ччи*  — элементы числовой последовательности

0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, …,
в которой первые два числа равны 0 и 1, а каждое последующее число равно сумме двух предыдущих чисел. Названы в честь средневекового математика Леонардо Пизанского (известного как Фибоначчи).

Реализуйте функцию ```fib()```. Функция вычисляет положительные числа Фибоначчи. Аргументом является порядковый номер числа.

**Формула:**

```JavaScropt
f(0) = 0
f(1) = 1
f(n) = f(n-1) + f(n-2)
```

**Вывод:**

```javascript
fib(0);  // 0
fib(1);  // 1
fib(3);  // 2
fib(10); // 55
```

## getIntersectionOfSortedArrays.js

Реализуйте функцию ```getIntersectionOfSortedArrays()```, которая принимает на вход два отсортированных массива и находит их пересечение. Пересечение двух массивов A и B — это массив только с теми элементами A и B, которые одновременно принадлежат обоим массивам, без дублей.

**Вывод:**

```JavaScript
getIntersectionOfSortedArrays([10, 11, 24], [10, 13, 14, 18, 24, 30]); // [10, 24]
 
getIntersectionOfSortedArrays([10, 11, 24], [-2, 3, 4]); // []
 
getIntersectionOfSortedArrays([], [2]); // []
```

Поиск пересечения двух неотсортированных массивов — операция, в рамках которой выполняется вложенный цикл с полной проверкой каждого элемента первого массива на вхождение во второй.

Сложность данного алгоритма O(n * m) (произведение n и m), где n и m — размерности массивов. Если массивы отсортированы, то можно реализовать алгоритм, сложность которого уже O(n + m), что значительно лучше.

Суть алгоритма довольно проста. В коде вводятся два указателя (индекса) на каждый из массивов. Начальное значение каждого указателя 0. Затем идёт проверка элементов, находящихся под этими индексами в обоих массивах. Если они совпадают, то значение заносится в результирующий массив, а оба индекса инкрементируются. Если значение в первом массиве больше, чем во втором, то инкрементируется указатель второго массива, иначе — первого.

## isBracketStructureBalanced.js

Реализуйте функцию ```isBracketStructureBalanced()```, которая принимает на вход строку, состоящую только из открывающих и закрывающих скобок разных типов, и проверяет, является ли эта строка сбалансированной. Открывающие и закрывающие скобки должны быть одного вида. Пустая строка (отсутствие скобок) считается сбалансированной.

Строка считается корректной (сбалансированной), если содержащаяся в ней скобочная структура соответствует требованиям:

Скобки — это парные структуры. У каждой открывающей скобки должна быть соответствующая ей закрывающая скобка.
Скобки должны закрываться в правильном порядке.

**Вывод:**

```JavaScript
// Пример вложенности
isBracketStructureBalanced('(>');  // false
isBracketStructureBalanced('()');  // true
isBracketStructureBalanced('[()]');  // true
isBracketStructureBalanced('({}[])');  // true
isBracketStructureBalanced('{<>}}'); // false
isBracketStructureBalanced('([)]'); // false
```

Функция должна поддерживать, минимум, четыре вида скобок: круглые — (), квадратные — [], фигурные — {} и угловые — <>.

## makeItFunny.js

Напишите функцию ```makeItFunny()```, которая принимает на вход строку и возвращает её копию, у которой каждый n-ный элемент переведен в верхний регистр. n – задается на входе в функцию.

Для определения каждого n-ного элемента понадобится остаток от деления %.

**Вывод:**

```javascript
const text = 'I never look back';
// Каждый третий элемент
makeItFunny(text, 3); // 'I NevEr LooK bAck'
```
