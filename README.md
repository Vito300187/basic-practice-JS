# basic-practice-JS

*This repository contains the best tests that I was lucky enough to deal with during the training on the Hexlet platform!*

![Hexlet logo](https://open-education.net/wp-content/uploads/2014/07/416970e1e2d4bb03297ec21b80507d2a-720x340.jpg)

## *Big O*

__Big O__ - Относительное представление сложности алгоритма кода. Показывает, как будет меняться производительность алгоритма от роста входящих данных.

От роста входных данных меняются 2 параметра:

1. Время, за которое будет отрабатывать наш алгоритм.
2. Колличество памяти, используемое данным алгоритмом для обработки всего объёма данных.

Скорость роста данных параметров показывает нам __Big O__.

__Примеры сложностей__:

1.__O(1)__ - константная (постоянная) сложность.

```JavaScript
function getLastElement(arr) {
    return arr[arr.length - 1];
};

// Функция отрабатывает за константное время
// вне зависимости от колличества данных, которые поступают на вход.
```

2.__O(n)__ - линейная сложность.

```JavaScript
function getSumOfArray(arr) {
    let sum = 0;

    for(let i = 0; i < arr.length; i += 1) {
        sum += arr[i];
    }

    return sum;
};

// Линейная зависимость времени на отработку данного алгоритма от колличества входных данных.
```

3.__O(log n)__ - логарифмическая сложность.

```JavaScript
let search = function(nums, target) {
    let left = 0;
    let right = nums.length - 1;
    let mid;

    while (left <= right) {
        mid = Math.round(x:(right - left) / 2) + left;

        if (target === nums[mid]) {
            return mid;
        } else if (target < nums[mid]) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }

    return -1;
};

// На каждой итерации берём массив данных и делим его на 2 части.
// Одну часть откидываем, то есть на каждой итерации мы уменьшаем объем данных вдвое.
```

4.__O(n log n)__

5.__O(n^2)__ - квадратичная сложность.

```JavaScript
function getMultiplyList(n) {
    for(let i = 1; i <= n; i++) {
        for(let j = 1; j <=n; j++) {
            console.log(`${i} * ${j} = ${i * j}`);
        }
    }
};
```

6.__O(n^3)__ - кубическая сложность.

7.__O(2^n)__ - экспоненциальная сложность.

```JavaScript
function getFib(n) {
    if (n < 2) {
        return n;
    }

    return getFib(n:n - 1) + getFib(n:n - 2);
};

// Количество операций растёт как на дрожжах.
```

8.__O(n!)__ - факториальная сложность.

![Big O](https://miro.medium.com/max/1400/1*fmbUKjjIjEprF8tiQJWgIg.png)

## bubbleSort.js

Реализуйте функцию ```bubbleSort()```

Пузырьковая сортировка (bubble sort)

Алгоритм состоит из повторяющихся проходов по сортируемому массиву. За каждый проход элементы последовательно сравниваются попарно и, если порядок в паре неверный, выполняется обмен элементов. Проходы по массиву повторяются N-1 раз или до тех пор, пока на очередном проходе не окажется, что обмены больше не нужны, что означает — массив отсортирован. При каждом проходе алгоритма по внутреннему циклу, очередной наибольший элемент массива ставится на своё место в конце массива рядом с предыдущим «наибольшим элементом», а наименьший элемент перемещается на одну позицию к началу массива («всплывает» до нужной позиции, как пузырёк в воде. Отсюда и название алгоритма).

__Вывод:__

```JavaScript
console.log(bubbleSort([14, 20, -10, -63, 0, 100, 33, -33]));
// [-63, -33, -10, 0, 14, 20, 33, 100]
```

## capitalizeWords.js

Дана строка текста. Нужно сделать заглавной __первую__ букву каждого слова в тексте. Для простоты считаем что мы работаем с текстом, который не содержит знаков препинания.

Реализуйте функцию ```capitalizeWords()```

__Вывод:__

```JavaScript
const text = 'hello world';
capitalizeWords(text); // 'Hello World'
```

Данное задание решить через преобразование строк в массив.

## encrypt.js

Разработайте программу, которая бы шифровала сообщения по следующему алгоритму. Она бы брала текст и переставляла в нем каждые два подряд идущих символа.

__Вывод:__

```JavaScript
encrypt('JavaScript');   // 'aJavcSirtp'
encrypt('Python'); // 'yPhtno'
 
// Если число символов нечётное,
// то последний символ остаётся на своём месте
encrypt('PHP'); // 'HPP'
```

Реализуйте функцию ```encrypt()```, которая принимает на вход исходное сообщение и возвращает зашифрованное.

## fibonacci-number.js

*Чи́сла Фибона́ччи*  — элементы числовой последовательности

0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, …,
в которой первые два числа равны 0 и 1, а каждое последующее число равно сумме двух предыдущих чисел. Названы в честь средневекового математика Леонардо Пизанского (известного как Фибоначчи).

Реализуйте функцию ```fib()```. Функция вычисляет положительные числа Фибоначчи. Аргументом является порядковый номер числа.

__Формула:__

```JavaScropt
f(0) = 0
f(1) = 1
f(n) = f(n-1) + f(n-2)
```

__Вывод:__

```javascript
fib(0);  // 0
fib(1);  // 1
fib(3);  // 2
fib(10); // 55
```

## fizzBuzz.js

Реализуйте функцию ```fizzBuzz()```, которая выводит ```(console.log)``` в терминал числа в диапазоне от begin до end. При этом:

Если число делится без остатка на 3, то вместо него выводится слово Fizz
Если число делится без остатка на 5, то вместо него выводится слово Buzz
Если число делится без остатка и на 3, и на 5, то вместо числа выводится слово FizzBuzz
В остальных случаях выводится само число
Функция принимает два параметра (begin и end), определяющих начало и конец диапазона (включительно). Для простоты считаем, что эти параметры являются целыми числами больше нуля. Если диапазон пуст (в случае, когда begin > end), то функция просто ничего не печатает.

__Вызов функции:__

```JavaScript
fizzBuzz(11, 20);
```

__Вывод в терминале:__

```JavaScript
11
Fizz
13
14
FizzBuzz
16
17
Fizz
19
Buzz

```

## getIntersectionOfSortedArrays.js

Реализуйте функцию ```getIntersectionOfSortedArrays()```, которая принимает на вход два отсортированных массива и находит их пересечение. Пересечение двух массивов A и B — это массив только с теми элементами A и B, которые одновременно принадлежат обоим массивам, без дублей.

__Вывод:__

```JavaScript
getIntersectionOfSortedArrays([10, 11, 24], [10, 13, 14, 18, 24, 30]); // [10, 24]
 
getIntersectionOfSortedArrays([10, 11, 24], [-2, 3, 4]); // []
 
getIntersectionOfSortedArrays([], [2]); // []
```

Поиск пересечения двух неотсортированных массивов — операция, в рамках которой выполняется вложенный цикл с полной проверкой каждого элемента первого массива на вхождение во второй.

Сложность данного алгоритма O(n * m) (произведение n и m), где n и m — размерности массивов. Если массивы отсортированы, то можно реализовать алгоритм, сложность которого уже O(n + m), что значительно лучше.

Суть алгоритма довольно проста. В коде вводятся два указателя (индекса) на каждый из массивов. Начальное значение каждого указателя 0. Затем идёт проверка элементов, находящихся под этими индексами в обоих массивах. Если они совпадают, то значение заносится в результирующий массив, а оба индекса инкрементируются. Если значение в первом массиве больше, чем во втором, то инкрементируется указатель второго массива, иначе — первого.

## isBracketStructureBalanced.js

Реализуйте функцию ```isBracketStructureBalanced()```, которая принимает на вход строку, состоящую только из открывающих и закрывающих скобок разных типов, и проверяет, является ли эта строка сбалансированной. Открывающие и закрывающие скобки должны быть одного вида. Пустая строка (отсутствие скобок) считается сбалансированной.

Строка считается корректной (сбалансированной), если содержащаяся в ней скобочная структура соответствует требованиям:

Скобки — это парные структуры. У каждой открывающей скобки должна быть соответствующая ей закрывающая скобка.
Скобки должны закрываться в правильном порядке.

__Вывод:__

```JavaScript
// Пример вложенности
isBracketStructureBalanced('(>');  // false
isBracketStructureBalanced('()');  // true
isBracketStructureBalanced('[()]');  // true
isBracketStructureBalanced('({}[])');  // true
isBracketStructureBalanced('{<>}}'); // false
isBracketStructureBalanced('([)]'); // false
```

Функция должна поддерживать, минимум, четыре вида скобок: круглые — (), квадратные — [], фигурные — {} и угловые — <>.

## makeItFunny.js

Напишите функцию ```makeItFunny()```, которая принимает на вход строку и возвращает её копию, у которой каждый n-ный элемент переведен в верхний регистр. n – задается на входе в функцию.

Для определения каждого n-ного элемента понадобится остаток от деления %.

__Вывод:__

```javascript
const text = 'I never look back';
// Каждый третий элемент
makeItFunny(text, 3); // 'I NevEr LooK bAck'
```
